# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZJaG5VmyO9oVuzQ1hfNL0Ec2rdp0jidx
"""

!pip install numpy matplotlib networkx gym

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import gym

print("Libraries are ready to use!")

import numpy as np
import matplotlib.pyplot as plt

# Step 1: Define a grid for the disaster zone
grid_size = (10, 10)  # 10x10 grid
disaster_zone = np.zeros(grid_size)

# Step 2: Add obstacles
obstacles = [(2, 3), (3, 3), (4, 3), (5, 5), (6, 7)]  # Example obstacle positions
for obs in obstacles:
    disaster_zone[obs] = 1

# Step 3: Add goals (rescue zones or supply drop points)
goals = [(8, 8), (1, 7)]  # Example goal positions
for goal in goals:
    disaster_zone[goal] = 2

# Step 4: Place the robot
robot_start = (0, 0)
disaster_zone[robot_start] = 3  # Mark the robot's starting position

# Step 5: Visualize the grid
plt.figure(figsize=(8, 8))
plt.imshow(disaster_zone, cmap='cool', origin='upper')
plt.title("Disaster Zone Simulation")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.xticks(range(grid_size[1]))
plt.yticks(range(grid_size[0]))
plt.grid(True)
plt.show()

def move_robot(start, goal, grid):
    """Simulates robot movement from start to goal."""
    current_position = start
    path = [start]  # Track the robot's path

    while current_position != goal:
        x, y = current_position
        gx, gy = goal

        # Determine movement direction
        if gx > x:  # Move down
            new_position = (x + 1, y)
        elif gx < x:  # Move up
            new_position = (x - 1, y)
        elif gy > y:  # Move right
            new_position = (x, y + 1)
        elif gy < y:  # Move left
            new_position = (x, y - 1)
        else:
            break  # Reached goal

        # Check for obstacles
        if grid[new_position] == 1:
            print(f"Obstacle at {new_position}, finding alternate path.")
            break

        # Update position
        grid[current_position] = 0  # Clear current position
        current_position = new_position
        grid[current_position] = 3  # Mark robot's new position
        path.append(current_position)

        # Visualize grid after each move
        plt.figure(figsize=(8, 8))
        plt.imshow(grid, cmap='cool', origin='upper')
        plt.title("Robot Moving...")
        plt.xlabel("X-axis")
        plt.ylabel("Y-axis")
        plt.grid(True)
        plt.show()

    print(f"Path taken: {path}")
    return path

# Set robot's goal
robot_goal = (8, 8)

# Simulate movement
robot_path = move_robot(robot_start, robot_goal, disaster_zone)

# Reset disaster zone visualization for each step
original_disaster_zone = disaster_zone.copy()  # Keep a copy of the original grid

for i, position in enumerate(smart_path):
    # Restore the original grid
    disaster_zone = original_disaster_zone.copy()

    # Highlight current robot position
    x, y = position
    disaster_zone[x, y] = 3  # Robot's current position

    # Plot the current state
    plt.figure(figsize=(8, 8))
    plt.imshow(disaster_zone, cmap='cool', origin='upper')
    plt.title(f"Smart Robot Moving... Step {i + 1}/{len(smart_path)}")
    plt.xlabel("X-axis")
    plt.ylabel("Y-axis")
    plt.grid(True)
    plt.show()

# Display the path at the end
print("Smart Path:", smart_path)



import numpy as np
import matplotlib.pyplot as plt
import random
from collections import deque
import time

# Define grid size and number of obstacles
GRID_SIZE = 8  # Use a grid of 8x8 for better visibility
OBSTACLE_COUNT = 5  # Number of obstacles

# Define start and goal positions
start = (0, 0)
goal = (7, 7)

# Initialize grid with obstacles
def initialize_grid():
    grid = np.zeros((GRID_SIZE, GRID_SIZE))

    # Add obstacles (we will add dynamic obstacles later)
    obstacles = []
    for _ in range(OBSTACLE_COUNT):
        x, y = random.randint(0, GRID_SIZE-1), random.randint(0, GRID_SIZE-1)
        while (x, y) == start or (x, y) == goal or (x, y) in obstacles:
            x, y = random.randint(0, GRID_SIZE-1), random.randint(0, GRID_SIZE-1)
        grid[x, y] = 1
        obstacles.append((x, y))
    return grid, obstacles

# BFS for pathfinding (simpler and more memory-efficient)
def bfs(grid, start, goal):
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right

    queue = deque([(start, [start])])  # (position, path so far)
    visited = set()
    visited.add(start)

    while queue:
        current, path = queue.popleft()

        if current == goal:
            return path

        for direction in directions:
            neighbor = (current[0] + direction[0], current[1] + direction[1])

            # Check if the neighbor is within bounds and not an obstacle
            if 0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE:
                if grid[neighbor[0], neighbor[1]] == 0 and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))

    return []  # Return an empty list if no path is found

# Move obstacles randomly
def move_obstacles(grid, obstacles):
    new_obstacles = []
    for (x, y) in obstacles:
        # Randomly move obstacle in 4 possible directions
        direction = random.choice([(-1, 0), (1, 0), (0, -1), (0, 1)])
        new_x, new_y = x + direction[0], y + direction[1]

        # Ensure new position is within bounds and not the start or goal
        if 0 <= new_x < GRID_SIZE and 0 <= new_y < GRID_SIZE and (new_x, new_y) != start and (new_x, new_y) != goal:
            new_obstacles.append((new_x, new_y))
            grid[x, y] = 0  # Clear the old obstacle position
            grid[new_x, new_y] = 1  # Place obstacle in new position
    return grid, new_obstacles

# Visualize grid with clear distinction between robot path, obstacles, and start/goal
def visualize_grid(grid, path=None, obstacles=None):
    fig, ax = plt.subplots(figsize=(6, 6))
    ax.imshow(grid, cmap='Blues', interpolation='nearest', extent=[0, GRID_SIZE, 0, GRID_SIZE])

    # Mark start, goal, and obstacles
    ax.text(start[1], start[0], 'S', ha='center', va='center', color='green', fontsize=14, fontweight='bold')
    ax.text(goal[1], goal[0], 'G', ha='center', va='center', color='red', fontsize=14, fontweight='bold')

    if obstacles:
        for obs in obstacles:
            ax.text(obs[1], obs[0], 'X', ha='center', va='center', color='black', fontsize=14, fontweight='bold')

    if path:
        for (x, y) in path:
            ax.text(y, x, '.', ha='center', va='center', color='blue', fontsize=14)

    # Display labels and title
    ax.set_xticks(np.arange(GRID_SIZE))
    ax.set_yticks(np.arange(GRID_SIZE))
    ax.set_xticklabels(np.arange(1, GRID_SIZE + 1))
    ax.set_yticklabels(np.arange(1, GRID_SIZE + 1))
    ax.set_title('Robot Path and Obstacles')
    plt.colorbar(ax.imshow(grid, cmap='Blues', interpolation='nearest'), ax=ax)
    plt.show()

# Function to navigate the robot
def navigate_robot(grid, start, goal):
    path = bfs(grid, start, goal)

    if not path:
        print("No path found!")
        return

    print(f"Goal reached in {len(path)} steps!")
    print("Final Path:", path)

    obstacles = [(x, y) for x in range(GRID_SIZE) for y in range(GRID_SIZE) if grid[x, y] == 1]

    # Visualize initial state
    visualize_grid(grid, obstacles=obstacles)

    # Move obstacles and show progress
    for step in range(len(path)):  # Visualize each step of the robotâ€™s movement
        if step < len(path):  # Make sure the step doesn't go out of bounds
            current_pos = path[step]
            if grid[current_pos[0], current_pos[1]] == 1:
                print(f"Path blocked at {current_pos} - Recalculating path...")
                path = bfs(grid, start, goal)

            # Visualize the path after each move
            visualize_grid(grid, path=path[:step+1], obstacles=obstacles)

            # Move obstacles every few steps
            if step % 3 == 0:
                grid, obstacles = move_obstacles(grid, obstacles)
                visualize_grid(grid, path=path[:step+1], obstacles=obstacles)  # Show updated grid

            time.sleep(1)  # Pause to simulate robot movement

    print("Robot reached the goal!")

# Initialize grid and obstacles
disaster_zone, obstacles = initialize_grid()

# Start robot navigation
navigate_robot(disaster_zone, start, goal)

import random
import matplotlib.pyplot as plt
import numpy as np

# Grid size
grid_size = 10

# Define the number of robots
num_robots = 3

# Define start and goal positions for each robot
robots = [{'start': (random.randint(0, grid_size-1), random.randint(0, grid_size-1)),
           'goal': (random.randint(0, grid_size-1), random.randint(0, grid_size-1)),
           'path': []} for _ in range(num_robots)]

# Create obstacles that will move
obstacles = [{'position': (random.randint(0, grid_size-1), random.randint(0, grid_size-1)),
              'direction': random.choice(['up', 'down', 'left', 'right'])} for _ in range(5)]

# Ensure robots and obstacles don't start at the same position
def ensure_no_overlap(robots, obstacles):
    all_positions = set()

    # Add initial positions of robots and obstacles to the set
    for robot in robots:
        all_positions.add(robot['start'])
    for obstacle in obstacles:
        all_positions.add(obstacle['position'])

    # Keep trying until no overlap
    for robot in robots:
        while robot['start'] in all_positions:
            robot['start'] = (random.randint(0, grid_size-1), random.randint(0, grid_size-1))
        all_positions.add(robot['start'])

    for obstacle in obstacles:
        while obstacle['position'] in all_positions:
            obstacle['position'] = (random.randint(0, grid_size-1), random.randint(0, grid_size-1))
        all_positions.add(obstacle['position'])

# Function to move obstacles randomly
def move_obstacles(obstacles):
    for obstacle in obstacles:
        x, y = obstacle['position']
        if obstacle['direction'] == 'up':
            x -= 1
        elif obstacle['direction'] == 'down':
            x += 1
        elif obstacle['direction'] == 'left':
            y -= 1
        elif obstacle['direction'] == 'right':
            y += 1

        # Keep obstacles within grid boundaries
        x = max(0, min(grid_size-1, x))
        y = max(0, min(grid_size-1, y))
        obstacle['position'] = (x, y)

        # Randomly change direction
        obstacle['direction'] = random.choice(['up', 'down', 'left', 'right'])

# Function to plot the grid and robots with distinct markers and colors
def plot_grid(robots, obstacles):
    grid = np.zeros((grid_size, grid_size))

    # Plot obstacles
    for obstacle in obstacles:
        x, y = obstacle['position']
        grid[x, y] = 2  # Mark obstacle position as 2

    # Plot robots
    for i, robot in enumerate(robots):
        x, y = robot['start']
        grid[x, y] = i + 3  # Mark robot starting position with unique values (3, 4, 5, ...)

    # Plot
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.imshow(grid, cmap='Pastel1', interpolation='nearest')

    # Add grid lines for better visual clarity
    ax.set_xticks(np.arange(-0.5, grid_size, 1), minor=True)
    ax.set_yticks(np.arange(-0.5, grid_size, 1), minor=True)
    ax.grid(which='minor', color='black', linestyle='-', linewidth=2)

    # Customize colors for robots and obstacles
    for i, robot in enumerate(robots):
        ax.text(robot['start'][1], robot['start'][0], f"R{i+1}", ha='center', va='center', color='black', fontweight='bold')

    for obstacle in obstacles:
        ax.text(obstacle['position'][1], obstacle['position'][0], "O", ha='center', va='center', color='red', fontweight='bold')

    # Title and labels
    ax.set_title("Robot and Obstacle Simulation", fontsize=16)
    plt.colorbar(ax.imshow(grid, cmap='Pastel1', interpolation='nearest'))
    plt.show()

# Ensure no overlap and initialize
ensure_no_overlap(robots, obstacles)

# Initialize and display the grid
move_obstacles(obstacles)
plot_grid(robots, obstacles)

import heapq

# Define the grid
GRID_SIZE = 10  # Size of the grid

# Directions for moving in 8 possible directions (diagonal and straight)
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]

# Heuristic function for A* (Manhattan distance)
def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

# A* algorithm for pathfinding
def a_star(grid, start, goal):
    open_list = []
    closed_list = set()
    heapq.heappush(open_list, (0 + heuristic(start, goal), 0, start, []))  # (f, g, position, path)

    while open_list:
        _, g, current, path = heapq.heappop(open_list)

        if current == goal:
            return path + [goal]

        closed_list.add(current)

        for move in MOVES:
            neighbor = (current[0] + move[0], current[1] + move[1])

            # Check if the neighbor is within bounds and not blocked
            if 0 <= neighbor[0] < GRID_SIZE and 0 <= neighbor[1] < GRID_SIZE:
                if grid[neighbor[0]][neighbor[1]] != 1 and neighbor not in closed_list:
                    new_cost = g + 1  # Each move has a cost of 1
                    heapq.heappush(open_list, (new_cost + heuristic(neighbor, goal), new_cost, neighbor, path + [current]))

    return []

# Function to update the grid with new obstacles
def update_grid(grid, obstacles):
    for obs in obstacles:
        grid[obs[0]][obs[1]] = 1  # Mark obstacle as blocked
    return grid

# Function to simulate robot movement with dynamic obstacles
def simulate_robot(grid, start, goal, obstacles):
    path = a_star(grid, start, goal)

    if not path:
        print("No path found!")
        return

    print("Initial path:", path)

    # Simulate the robot's movement and obstacle detection
    for i, position in enumerate(path):
        grid = update_grid(grid, obstacles)  # Update obstacles in the grid

        # Print robot's current position and grid
        print(f"Step {i + 1}: Robot moved to {position}")

        # Check if the robot has encountered a dynamic obstacle
        if position in obstacles:
            print(f"Obstacle detected at {position}. Recalculating path...")
            path = a_star(grid, position, goal)
            print("Recalculated path:", path)
            if not path:
                print("Failed to recalculate path!")
                return

# Define a sample grid and obstacles
grid = [[0 for _ in range(GRID_SIZE)] for _ in range(GRID_SIZE)]  # 0 represents free space, 1 represents obstacles
start = (0, 0)  # Starting position
goal = (8, 8)  # Goal position
obstacles = [(3, 3), (4, 4), (5, 5)]  # Obstacles on the grid

# Start the robot simulation
simulate_robot(grid, start, goal, obstacles)

import numpy as np
import matplotlib.pyplot as plt
import random

# Define Robot class
class Robot:
    def __init__(self, robot_id, start, goal):
        self.id = robot_id
        self.position = start
        self.goal = goal
        self.path = []

    def move_with_safety_check(self, position):
        if position not in self.path:  # Prevent adding the same position
            self.position = position
            self.path.append(position)

# A* Algorithm
def a_star(start, goal, grid, obstacles, robots):
    open_list = [start]
    closed_list = set()
    came_from = {}
    g_score = {start: 0}
    f_score = {start: np.linalg.norm(np.array(start) - np.array(goal))}

    while open_list:
        current = min(open_list, key=lambda x: f_score.get(x, float('inf')))
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.reverse()
            return path

        open_list.remove(current)
        closed_list.add(current)

        neighbors = [(current[0] + 1, current[1]), (current[0] - 1, current[1]),
                     (current[0], current[1] + 1), (current[0], current[1] - 1)]
        for neighbor in neighbors:
            if neighbor in closed_list or neighbor in obstacles or neighbor in [robot.position for robot in robots]:
                continue
            tentative_g_score = g_score.get(current, float('inf')) + 1
            if neighbor not in open_list or tentative_g_score < g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + np.linalg.norm(np.array(neighbor) - np.array(goal))
                if neighbor not in open_list:
                    open_list.append(neighbor)

    return []

# Function to simulate robots' movements
def simulate_robots(grid, start_positions, goal, num_obstacles):
    robots = [Robot(i, start, goal) for i, start in enumerate(start_positions)]
    obstacles = set()

    # Place initial obstacles
    while len(obstacles) < num_obstacles:
        obs = (random.randint(0, grid.shape[0] - 1), random.randint(0, grid.shape[1] - 1))
        obstacles.add(obs)

    step = 0
    while True:
        step += 1
        plt.clf()  # Clear previous plot
        plt.imshow(grid, cmap='Blues', origin='upper')

        # Plot start positions
        plt.scatter([pos[1] for pos in start_positions], [pos[0] for pos in start_positions], color='green', label='Start', s=150, marker='*')

        # Plot goal position
        plt.scatter(goal[1], goal[0], color='yellow', label='Goal', s=150, marker='X')

        # Plot robots and their paths
        for i, robot in enumerate(robots):
            if robot.path:
                path = np.array(robot.path)
                plt.plot(path[:, 1], path[:, 0], label=f'Robot {robot.id} Path', marker='o', linestyle='-', markersize=5, alpha=0.6, color=f'C{i}')
            plt.scatter(robot.position[1], robot.position[0], color=f'C{i}', label=f'Robot {robot.id} Position', s=100)

        # Plot obstacles
        plt.scatter([obs[1] for obs in obstacles], [obs[0] for obs in obstacles], color='red', label='Obstacle', marker='s', s=100)

        # Update the plot
        plt.legend(loc='upper right', fontsize=10)
        plt.title("Robot Navigation Simulation", fontsize=14)
        plt.grid(True)
        plt.pause(0.1)

        all_reached_goal = True
        for robot in robots:
            path = a_star(robot.position, robot.goal, grid, obstacles, robots)
            if path:
                robot.move_with_safety_check(path[0])  # Move to the next position in the path

            # Check if robot has reached the goal
            if robot.position != robot.goal:
                all_reached_goal = False

        if all_reached_goal:
            print("All robots have reached the goal!")
            break

        # Randomly update obstacles' positions
        new_obstacles = set()
        while len(new_obstacles) < num_obstacles:
            obs = (random.randint(0, grid.shape[0] - 1), random.randint(0, grid.shape[1] - 1))
            new_obstacles.add(obs)
        obstacles = new_obstacles

# Create a grid (10x10)
grid = np.zeros((10, 10))

# Define start positions and goal
start_positions = [(0, 0), (0, 1), (0, 2)]  # 3 robots starting positions
goal = (9, 9)  # Goal position

# Simulate with 5 obstacles
simulate_robots(grid, start_positions, goal, 5)  # 5 obstacles